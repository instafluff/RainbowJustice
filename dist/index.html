<html>
  <head>
    <title>Rainbow Rampage</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135113520-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-135113520-1');
    </script>
    <link rel='stylesheet' href='unicorn.css' />
    <script src="pinkfluffyunicorn.min.js"></script>
    <script src="brain.min.js"></script>
  </head>
  <body>
    <div id="unicorn-display"></div>
    <script>
      const params = new URLSearchParams(location.search);
      window.WebFontConfig = {
          google: {
              families: ['Luckiest Guy', 'Geo'],
          },
          active() {
              CreateGame();
          },
      };

      /* eslint-disable */
      // include the web-font loader script
      (function() {
          const wf = document.createElement('script');
          wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'
          }://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;
          wf.type = 'text/javascript';
          wf.async = 'true';
          const s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(wf, s);
      }());
      /* eslint-enabled */

      var teapupQuotes = [
        "TASTE MY RAINBOW MOMMAPUPPERS!!",
        "Skittle, skedaddle.",
        "Vroom vroom.. to your DOOM!",
        "NO HALLOWEEN MAKES TEAPUP HANGRY!",
        "This one is for Prof. Fluffington!",
        "Winner Winner Skittles Dinner",
        "Taste this rainbow cannon's fury!",
        "Eat colors and weep!",
        "Enjoy my cavity canon!",
        "Do I still seem sweet to you?",
        "Someone call Dr. Bazooka Joe",
        "Trick or Treat!",
        "I'M THE SWEETEST!",
        "SUGAR ME TIMBERS!",
        "MyRainbowBringsAllDaDogsToTheYard~",
      ];
      var teapupHelp = [
        "Please specify a Twitch channel",
        "You can see how at instafluff.tv",
        "www.instafluff.tv/RainbowRampage"
      ];
      var teapupIntro = [
        "so this is Sugar-Free HQ...",
        "they can't ban Halloween forever.",
        "NOT IF I CAN HELP IT",
        "!candytime to Begin!"
      ];
      var teapupWin = [
        "YAAAAAAAAAAAAAAAAAAAAAS!",
        "I am the Hallowqueen!",
        "try '!candytime hard' for hard mode!",
        "thanks to the following people",
        "for making me a STAR!",
      ];
      var teapupGameOver = [
        "ouch",
        "I'll be back!",
        "rip",
        "that hurt.",
        "where'd I put my puprocks?",
        "RAWRRRR",
        "AHHHHHHHHHHHHHHHHH"
      ];
      var credits = [ "Instafluff", "ElysiaGriffin", "!skip to play again", "2Danno", "8bitHug", "Adariousmist", "AgroKragle", "Amarogine", "AntiViGames", "Aries41745", "Astrobinary", "BanzaiBaby", "Betha", "BigZach", "Bjwhite211", "Bloom_jiminy", "BlueJellyCam", "BountyHunterLani", "BrainoidGames", "Breci", "BungalowGlow", "BunkaHi", "Bustopher", "CearkaLarue", "Chibigirl24", "CodebaseAlpha", "CreativeBuilds", "CyberNinjaGaming_UK", "DEAD_P1XL", "Dangalicious", "DannyKampsGamez", "DevMerlin", "DevonGH", "Dexqyen", "Docpinecone", "Doubaltsey", "DrJavaSaurus", "Dsplits", "DutchGamer46", "ELgnad", "Easymacman", "Ella_Fint", "EndlessMoonfall", "EndlessSonrise", "Everything_is_awes0me", "EvilCanadian", "FBail", "Fisune", "Flippo13", "FranC312", "FuriousFur", "GameDevCompany", "Gamezdad", "Gilokk0", "Glenn___", "Gorogokvi", "GrimAquatic", "Grognardian", "HeyOhKei", "HonestDanGames", "Im_Kritz", "Instafluff", "Instafriend", "InstantlyFire", "JMSWRNR", "JaiTekk", "JenniNexus", "JoeShimHae", "Jormunduur", "Joshelisk", "Jwh1o1", "K1ng440", "Kara_Kim", "Khaled__", "KitAnnLIVE", "Krakka25", "Kushimitama", "Kyoslilmonster", "Lahtnaa", "LiliaHarlow", "LilyHazel", "Little_Bungorf", "LordOverflow", "Lord_of_Conquest", "LuRiMer313", "LuckyPheathers", "M4Mons", "MacabreMan2", "MalForTheWin", "Maladath1980", "MangoMaestro", "MartianGames", "McKleaver", "MerlinLeWizard", "Miraellyn", "Moopaloo", "MrRayKoma", "MsSaltyGiggles", "MudBocx", "Neo_TA", "NinjaFalcon_2", "NoiceNToight", "NotDenaerys", "Nrwgn_VKNG", "Optik_Nerve", "PlatYellow", "RIKACHET", "Raevin10", "Ralnorin", "RikuRinku", "Rivverdragon", "RocknightStudios", "Samthe718manlol", "SausageCam", "ScrtSolstice", "Shaggz13", "SoftshellTCCT", "SpikeTiger", "Starlet_Blossom", "Succatash", "Supascury", "SushiDay", "Talk2meGooseman", "That_MS_Gamer", "TheBardVyune", "TheHugoDahl", "TheRealArman", "TheSandwichKitsune", "TheSpiceWizard", "TheVividLotus", "Theoneandonlybigbadmo", "ThiccMercs_", "Toomuchcoffe", "Typhoon22288", "Uberblacktorne", "UncleStinky3921", "WhatTheStuck", "WolvesGamingDen", "Xaiydee", "Xolti", "XxPhantasmaxX", "Xynal", "ZallixSilver", "ZobStan", "ZpeedTube", "aj2017", "arnab345madd", "baileydale", "blakeparsons12", "born_to_be_smart", "brandan_f", "bscolaro", "carlosdlroca", "cartufer", "cengo5x7", "codephobia", "cottonsmiles", "danielbrown864", "darkblaze176", "dcj44", "donaldwm", "duartubetv", "etisdew", "feliiax", "fpicoitoj", "fydo", "gabrielgabu", "gamemodeon232", "gamezmom", "genos3", "guppygirl777", "guthron", "heysatou", "holloway87", "infectious_karma", "itsuNu", "jellydance", "juan_cena_rl", "julieee22", "kittybubbly026", "koralina211", "llofyy", "losthewar", "malfunct", "marcmagus", "marss112", "miniaturegard3n", "mmtaleghani", "mrbinary001", "n1k1cha_pff", "nick_larsen", "nightsilas", "not_a_n1nja", "oldrop", "oliveriib", "pawsitivelystitched", "peterf28", "pujolsluis", "puppymaister", "robowarrior1982", "rockysenpai24", "roidz999", "saoigames", "shadowcraft5", "simrose4u", "smilesandtea", "sokanuchan", "songfox", "sorskoot", "sparky_pugwash", "spartaremix1", "stresstest", "superjesse07", "theMichaelJolley", "thegooseofwild", "thomasnhermansen", "tiger_k1ng", "trufflette", "くコ彡" ];

      var gameState = "start"; // start, vote, battle, end, win
      var titleWin;
      var titleTimer = 0;
      var winText = -1;
      var winTextTimer = 0;
      var introText = -1;
      var introTextTimer = 1000;
      var counter = 0;
      var tpTrike = null;
      var tpExhaust = [];
      var tpEmptyHearts = [];
      var tpFullHearts = [];
      const tpMaxHP = 5;
      var tpHP = 1;
      var tpAngle = 0;
      var tpSpeed = 2;
      var tpAimAngle = 0;
      var tpImage;
      var tpVote = [];
      var tpDeathTimer = 0;
      var voteStar;
      var voteText;
      var upgradeImages = [];
      var winningUpgrade = 0;
      var upgradeAnimTimer = 0;
      var speechBubbles = [];
      var speechBubbleText;
      var isLongSpeechText = false;
      var isSpeechBubbleShowing = false;
      var shieldTime = 2000;
      var shieldTimer = 0;
      // 3 waves per round, 3 rounds before a boss
      var roundCount = 3;
      var roundNumber = 0;
      var warpDark, warpLight;
      var isSpawningEnemies = false;
      var warpSize = 0;
      var waveCount = 3;
      var waveNumber = 0;
      var enemyLevel = 1;
      var enemies = [];
      var bosscat = [];
      var bossTimer = 0;
      var bossMaxHP = 1000;
      var bossEndLevel = 5;
      var bossHP = 0;
      var bossHealthBar, bossHealthBarContainer;
      var isBossLevel = false;
      var hpText = null;
      var firingRate = 2000;
      var firingCount = 1;
      var numFiringRateUpgrades = 1;
      var fireTime = 0;
      var skittles = [];
      var voteTime = 30000;
      var voteTimer = 0;
      var voteTimeBar;
      var votes = {};
      var votePower = Math.random() * 0.1, voteSpeed = Math.random() * 0.1, voteHeal = Math.random() * 0.1;

      function startVote() {
        gameState = "vote";
        voteTimer = voteTime;
        votes = {};
        votePower = Math.random() * 0.1;
        voteSpeed = Math.random() * 0.1;
        voteHeal = Math.random() * 0.1;
        console.log( "Vote: !power !speed !heal" );
        waveNumber = 0;
        roundNumber++;
        console.log( "ROUND:", roundNumber );
        if( roundNumber >= roundCount ) {
          roundNumber = 0;
          enemyLevel++;
          if( enemyLevel >= bossEndLevel ) {
            // FINAL BOSS
            startBattle();
            tpHP = tpMaxHP; // Heal Teapup to full
            refreshVisibleHP();
            spawnCaptain( 640, 360, bossMaxHP );
          }
        }
        speechBubbles.forEach( s => s.visible = false );
        speechBubbleText.visible = false;
        tpImage.alpha = 1;
        tpImage.tint = 0xffffff;
      }

      function showSpeechBubble( text ) {
        isSpeechBubbleShowing = true;
        isLongSpeechText = text.length > 20;
        if( text.length >= 35 ) {
          text = text.slice( 0, 33 ) + "..";
        }
        setTimeout( () => {
          isSpeechBubbleShowing = false;
          speechBubbleText.visible = false;
          speechBubbles.forEach( x => x.visible = false );
        }, 3000 );
        speechBubbleText.text = text;
      }

      function startBattle() {
        gameState = "battle";
        voteText.visible = false;
        speechBubbleText.visible = false;
      }

      function endGame() {
        gameState = "end";
        tpTrike.isStatic = true;
        tpImage.alpha = 1;
        tpImage.tint = 0xffffff;
        tpDeathTimer = 1500;
        setTimeout( () => {
          showSpeechBubble( teapupGameOver[ getRandomInt( teapupGameOver.length ) ] );
        }, tpDeathTimer );

        setTimeout( () => {
          location.reload();
        }, 20000 );
      }

      function winGame() {
        gameState = "win";
        tpImage.alpha = 1;
        tpImage.tint = 0xffffff;
        enemies.forEach( x => x.isStatic = true );
        bossHealthBarContainer.x = -1000;
        bossHealthBar.x = -1000;
        // Show "ahh" cat
        bosscat[ 1 ].x = 640;
        bosscat[ 1 ].y = 360;
        bosscat[ 0 ].x = -1000;
        setTimeout( () => {
          titleTimer = 1000;
        }, 4000 );
        winTextTimer = 10;
      }

      function aiCompute( rayVals ) {
        var rayMax = 0;
        var numCasts = rayVals.length;
        for( var i = 0; i < numCasts; i++ ) {
          var factor = i / ( numCasts - 1 );
          var mid = ( numCasts - 1 ) / 2;
          var change = ( mid - Math.abs( i - mid ) ) / mid;
          rayMax += 120 * change + 70;
        }
        var total = 0, leftTotal = 0, rightTotal = 0;
        for( var i = 0, len = rayVals.length / 2; i < len; i++ ) {
          leftTotal += rayVals[ i ];
        }
        for( var i = Math.floor( rayVals.length / 2 ), len = rayVals.length; i < len; i++ ) {
          rightTotal += rayVals[ i ];
        }
        total = rayVals.reduce( (a, b) => a + b );
        var pikaState;
        if( total > 0 && total < rayMax - 10 ) {
          if( total < rayMax / 2 ) { // Too close to everything so try and turn left
            pikaState = "left";
          }
          else if( leftTotal > rightTotal ) {
            pikaState = "left";
          }
          else {
            pikaState = "right";
          }
        }
        else {
          pikaState = "idle";
        }
        // console.log( pikaState );
        switch( pikaState ) {
          case "left":
            return -90;
          case "right":
            return 90;
          case "idle":
          default:
            return 0;
        }
      }

      function aimTeapup( timeDiff ) {
        var closestEnemy = -1, closestDist = 1000000;
        var pX = tpTrike.position.x, pY = tpTrike.position.y;
        enemies.forEach( (x, i) => {
          var dX = x.position.x - pX, dY = x.position.y - pY;
          var dist = dX * dX + dY * dY;
          if( dist < closestDist ) {
            closestEnemy = i;
            closestDist = dist;
          }
        });
        if( closestEnemy >= 0 ) {
          var enemy = enemies[ closestEnemy ];
          var dX = enemy.position.x - pX, dY = enemy.position.y - pY;
          tpAimAngle = Math.atan2( dY, dX );
        }
        else if( isBossLevel ) {
          var dX = 640 - pX, dY = 360 - pY;
          tpAimAngle = Math.atan2( dY, dX );
        }
        // else {
        //   // Turn towards where Teapup is moving
        //   tpAimAngle = tpAngle;
        // }
        tpImage.transform.rotation = tpAimAngle;
      }

      function simulateWorld( targetX, targetY, objects,  timeDiff ) {
        return objects.map( a => {
          var dX = targetX - a.x, dY = targetY - a.y;
          var length = Math.sqrt( dX * dX + dY * dY );
          return { x: a.x + dX / length * a.speed * timeDiff, y: a.y + dY / length * a.speed * timeDiff, speed: a.speed }
          } );
      }

      function scoreWorld( pX, pY, objects ) {
        var totalScore = 0;
        // Check walls
        if( pX <= 120 ) {
          totalScore -= 120 - pX;
        }
        if( pX >= 1280 - 120 ) {
          totalScore -= pX - ( 1280 - 120 - 120 );
        }
        if( pY <= 120 ) {
          totalScore -= 120 - pY;
        }
        if( pY >= 720 - 120 ) {
          totalScore -= pY - ( 720 - 120 - 120 );
        }
        if( isBossLevel ) {
          var dX = 640 - pX, dY = 360 - pY;
          var dist2 = dX * dX + dY * dY;
          if( dist2 < 280 * 280 ) {
            totalScore -= 280 - Math.sqrt( dist2 );
          }
        }
        objects.forEach( o => {
          var dX = o.x - pX, dY = o.y - pY;
          var dist2 = dX * dX + dY * dY;
          if( dist2 < 260 * 260 ) { // 200 px away from teapup
            totalScore -= 260 - Math.sqrt( dist2 );
          }
        });
        return totalScore;
      }

      function scoreAndSimTeapup( turnAngle, objects, timeStep ) {
        var nextX = tpImage.x + tpSpeed * Math.cos( tpAngle + turnAngle );
        var nextY = tpImage.y + tpSpeed * Math.sin( tpAngle + turnAngle );
        var world = simulateWorld( nextY, nextY, objects, timeStep );
        var score = scoreWorld( nextX, nextY, world );
        return score;
      }

      function driveTeapup( timeDiff ) {
        var current = enemies.map( e => ({ x: e.position.x, y: e.position.y, speed: e.moveSpeed }) );
        // Calculate a score for left, straight, right
        var currentScore = scoreWorld( tpImage.x, tpImage.y, current );
        const timeStep = 100;
        var left = scoreAndSimTeapup( -30 * ( 2 * Math.PI / 360 ) * timeStep / 1000 * 4, current, timeStep );
        var right = scoreAndSimTeapup( 30 * ( 2 * Math.PI / 360 ) * timeStep / 1000 * 4, current, timeStep );
        var front = scoreAndSimTeapup( 0, current, timeStep );
        var maxScore = Math.max( left, Math.max( right, front ) );
        var turnAngle = 0;
        if( maxScore === front ) {
          turnAngle = 0;
        }
        else if( maxScore === right ) {
          turnAngle = 30 * timeDiff / 1000 * 4;
        }
        else {
          turnAngle = -30 * timeDiff / 1000 * 4;
        }
        // console.log( tpTrike.angle + " + " + turnAngle * ( 2 * Math.PI / 360 ) );
        tpAngle += turnAngle * ( 2 * Math.PI / 360 );
        if( tpAngle < -Math.PI * 2 ) {
          tpAngle += Math.PI * 2;
        }
        if( tpAngle > Math.PI * 2 ) {
          tpAngle -= Math.PI * 2;
        }
        tpTrike.angle = tpAngle;
        // console.log( tpTrike );
        Matter.Body.setVelocity( tpTrike, { x: Math.cos( tpAngle ) * tpSpeed, y: Math.sin( tpAngle ) * tpSpeed } );
      }

      function shootSkittle() {
        var dirX = Math.cos( tpAimAngle );
        var dirY = Math.sin( tpAimAngle );
        var sX = tpTrike.position.x + dirX * 60;
        var sY = tpTrike.position.y + dirY * 60;
        var bulletX = Math.cos( tpAimAngle + Math.random() * -0.005 + 0.0005 );
        var bulletY = Math.sin( tpAimAngle + Math.random() * -0.005 + 0.0005 );
        var color = getRandomInt( 6 );
        var sprite = "skittleBlue";
        switch( color ) {
          case 0:
            color = 0x1474bb;
            sprite = "skittleBlue";
            break;
          case 1:
            color = 0xe41e26;
            sprite = "skittleRed";
            break;
          case 2:
            color = 0x8fc33e;
            sprite = "skittleGreen";
            break;
          case 3:
            color = 0x5d2b7d;
            sprite = "skittlePurple";
            break;
          case 4:
            color = 0xfeee22;
            sprite = "skittleYellow";
            break;
          case 5:
            color = 0xa72d89;
            sprite = "skittleViolet";
            break;
        }
        var skittle = Unicorn.AddObject( "skittle" + counter++, {
              type: "circle",
              x: sX, y: sY,
              radius: 8,
              sprite: sprite,
              bounce: 0,
            } );
        skittle.force.x = bulletX * 0.01;
        skittle.force.y = bulletY * 0.01;
        skittle.life = 500;
        skittle.color = color;
        skittles.push( skittle );
      }

      function spawnTeapup( x, y, health ) {
        tpHP = health;
        tpExhaust.push( Unicorn.AddOverlay( "exhaustRed", "exhaustRed", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustBlue", "exhaustBlue", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustYellow", "exhaustYellow", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustViolet", "exhaustViolet", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustGreen", "exhaustGreen", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustPurple", "exhaustPurple", x, y ) );
        tpExhaust.forEach( e => {
          e.anchor.set( 0.5 );
        });
        tpTrike = Unicorn.AddObject( "tricycle", {
          type: "circle",
          x, y,
          radius: 60,
          sprite: "tricycle",
          bounce: 0.9,
          onEnter: ( label, body ) => {
            if( label.startsWith( "enemy" ) ) {
              // We hit a new enemy!
              if( shieldTimer <= 0 ) {
                console.log( "ouch cheese!" );
                if( tpHP > 0 ) {
                  tpHP--;
                  refreshVisibleHP();
                  if( tpHP <= 0 ) {
                    // GAME OVER!!!
                    console.log( "GAME OVER" );
                    endGame();
                  }
                  else {
                    shieldTimer = shieldTime;
                  }
                }
              }
            }
          }
        } );
        tpImage = Unicorn.AddOverlay( "teapup", "teapup", x, y );
        tpImage.anchor.set( 0.5 );
      }

      function spawnEnemy( x, y, health, speed, type ) {
        var objectType, sprite, size;
        switch( type ) {
          case "robot":
            objectType = "rectangle";
            sprite = "robot";
            size = 50;
            break;
          case "drone":
            objectType = "circle";
            sprite = "drone";
            size = 25;
            break;
          case "tank":
            objectType = "rectangle";
            sprite = "tank";
            size = 100;
            break;
        }
        let enemy = Unicorn.AddObject( "enemy" + counter++, {
          type: objectType,
          x, y,
          width: size, height: size,
          radius: size,
          sprite: sprite,
          bounce: 0,
          onEnter: ( label, body ) => {
            // Check for bullets!
            if( label.startsWith( "skittle" ) ) {
              // KABOOM
              let candyPieces = Unicorn.AddParticles( "candy" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: body.color,
                  endColor: body.color,
                  blendMode: PIXI.BLEND_MODES.OVERLAY,
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.1,
                  maxSpeed: 0.25,
                  decay: 1, // Scale from 0 - 10
                }, body.position.x, body.position.y );
              setTimeout( () => {
                  Unicorn.RemoveParticles( candyPieces.name );
                }, 100 );
              // console.log( body );
              // Remove Skittle
              var skittleIndex = skittles.findIndex( s => s.label === label );
              if( skittleIndex >= 0 ) {
                skittles.splice( skittleIndex, 1 );
              }
              Unicorn.RemoveObject( label );
              enemy.health--;
              if( enemy.health <= 0 ) {
                // DED ENEMY
                let explosion = Unicorn.AddParticles( "explosion" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: "#FB8200",
                  endColor: "#FEBE79",
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.1,
                  maxSpeed: 0.25,
                  decay: 1, // Scale from 0 - 10
                }, enemy.position.x, enemy.position.y );
                let pieces = Unicorn.AddParticles( "pieces" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: "#4A4957",
                  endColor: "#4A4957",
                  blendMode: PIXI.BLEND_MODES.DARKEN,
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.01,
                  maxSpeed: 0.025,
                  decay: 1, // Scale from 0 - 10
                }, enemy.position.x, enemy.position.y );
                setTimeout( () => {
                  Unicorn.RemoveParticles( explosion.name );
                  Unicorn.RemoveParticles( pieces.name );
                }, 100 );
                enemies.splice( enemies.indexOf( enemy ), 1 );
                Unicorn.RemoveObject( enemy.label );
              }
            }
          }
        } );
        enemy.health = health;
        enemy.moveSpeed = speed;
        enemies.push( enemy );
      }

      function spawnEnemyWave( size ) {
        // TODO: Add multiple types of enemies
        // Select a warp spot away from Teapup
        let x = getRandomInt( 640 ), y = getRandomInt( 360 );
        if( tpTrike.position.x < 640 ) {
          x += 640;
        }
        if( tpTrike.position.y < 360 ) {
          y += 360;
        }
        warpSize = 0;
        isSpawningEnemies = true;
        warpDark.x = x; warpDark.y = y;
        warpLight.x = x; warpLight.y = y;
        warpDark.transform.scale.x = warpDark.transform.scale.y = warpSize;
        warpLight.transform.scale.x = warpLight.transform.scale.y = warpSize;
        setTimeout( () => {
          isSpawningEnemies = false;
          for( var i = 0; i < size; i++ ) {
            if( enemyLevel > 2 ) {
              var chance = Math.random();
              if( chance < 0.1 ) {
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, ( enemyLevel - 2 ) * 20 + 1, 0.5, "tank" );
                i++;
              }
              else if( chance < 0.50 ) {
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, ( enemyLevel - 1 ) + 1, 1, "robot" );
              }
              else {
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
              }
            }
            else if( enemyLevel > 1 ) {
              if( Math.random() < 0.25 ) {
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, ( enemyLevel - 1 ) + 1, 1, "robot" );
              }
              else {
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
                spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, 1, 3, "drone" );
              }
            }
            else {
              spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, ( enemyLevel - 1 ) + 1, 1, "robot" );
            }
          }
        }, 500 );
        // let spawner = setInterval( () => {
        //   size--;
        //   if( size <= 0 ) {
        //     clearInterval( spawner );
        //   }

        // }, 500 );
      }

      function spawnCaptain( x, y, health ) {
        bossHP = health;
        let boss = Unicorn.AddObject( "enemybosscat", {
          type: "circle",
          x, y,
          radius: 100,
          bounce: 0,
          sprite: "skittleBlue",
          isStatic: true,
          onEnter: ( label, body ) => {
            // Check for bullets!
            if( label.startsWith( "skittle" ) ) {
              // KABOOM
              let candyPieces = Unicorn.AddParticles( "candy" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: body.color,
                  endColor: body.color,
                  blendMode: PIXI.BLEND_MODES.OVERLAY,
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.1,
                  maxSpeed: 0.25,
                  decay: 1, // Scale from 0 - 10
                }, body.position.x, body.position.y );
              setTimeout( () => {
                  Unicorn.RemoveParticles( candyPieces.name );
                }, 100 );
              // console.log( body );
              // Remove Skittle
              var skittleIndex = skittles.findIndex( s => s.label === label );
              if( skittleIndex >= 0 ) {
                skittles.splice( skittleIndex, 1 );
              }
              Unicorn.RemoveObject( label );
              bossHP--;
              if( bossHP <= 0 ) {
                // DED BOSS
                winGame();
                let redParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0xe41e26,
                    endColor: 0xe41e26,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                let blueParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0x1474bb,
                    endColor: 0x1474bb,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                let greenParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0x8fc33e,
                    endColor: 0x8fc33e,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                let purpleParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0x5d2b7d,
                    endColor: 0x5d2b7d,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                let yellowParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0xfeee22,
                    endColor: 0xfeee22,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                let violetParticles = Unicorn.AddParticles( "win" + counter++, {
                    shape: "circle", // "cone", "line"
                    startColor: 0xa72d89,
                    endColor: 0xa72d89,
                    blendMode: PIXI.BLEND_MODES.OVERLAY,
                    intensity: 10, // Scale from 1 - 10
                    minSpeed: 0.1,
                    maxSpeed: 0.25,
                    decay: 1, // Scale from 0 - 10
                  }, x, y );
                setTimeout( () => {
                  Unicorn.RemoveParticles( redParticles.name );
                  Unicorn.RemoveParticles( blueParticles.name );
                  Unicorn.RemoveParticles( greenParticles.name );
                  Unicorn.RemoveParticles( purpleParticles.name );
                  Unicorn.RemoveParticles( yellowParticles.name );
                  Unicorn.RemoveParticles( violetParticles.name );
                }, 5000 );
                Unicorn.RemoveObject( boss.label );
              }
            }
          }
        } );
        boss.sprite.alpha = 0;
        isBossLevel = true;
        bossTimer = 3000;
      }

      function Init() {
        // Add Initialization Here
        LoadAssets();
        // Unicorn.AddText( "title", "Rainbow Rampage", 50, 50, {
        //   fontFamily: "Luckiest Guy",
        //   fontSize: 120,
        //   // fontWeight: 'bold',
        //   fill: "#000000"
        // });
        warpLight = Unicorn.AddOverlay( "warpLight", "warpLight", -1000, -1000 );
        warpDark = Unicorn.AddOverlay( "warpDark", "warpDark", -1000, -1000 );
        warpLight.anchor.set( 0.5 );
        warpDark.anchor.set( 0.5 );
        for( var i = 0; i < tpMaxHP; i++ ) {
          tpEmptyHearts.push( Unicorn.AddOverlay( "heart_empty" + i, "heart_empty", 100, 100 ) );
          tpFullHearts.push( Unicorn.AddOverlay( "heart_full" + i, "heart_full", 100, 100 ) );
        }
        // hpText = Unicorn.AddText( "health", tpHP, 300, 500, {
        //   fontFamily: 'Bubblegum Sans',
        //   fontSize: 36,
        //   fontWeight: 'bold',
        //   fill: "#000000"
        // });
        bosscat.push( Unicorn.AddOverlay( "bosscat1", "bosscat1", -1000, 0 ) );
        bosscat.push( Unicorn.AddOverlay( "bosscat2", "bosscat2", -1000, 0 ) );
        bosscat.forEach( b => b.anchor.set( 0.5 ) );
        bossHealthBarContainer = Unicorn.AddOverlay( "healthBarContainer", "healthBarContainer", -1000, 0 );
        bossHealthBar = Unicorn.AddOverlay( "healthBar", "healthBar", -1000, 0 );
        titleWin = Unicorn.AddOverlay( "titleWin", "titleWin", -1000, 0 );
        titleWin.anchor.set( 0.5 );
        spawnTeapup( 640, 360, tpMaxHP );
        tpVote.push( Unicorn.AddOverlay( "voteL", "voteL", -1000, -1000 ) );
        tpVote.push( Unicorn.AddOverlay( "voteR", "voteR", -1000, -1000 ) );
        tpVote.push( Unicorn.AddOverlay( "voteL2", "voteL2", -1000, -1000 ) );
        tpVote.push( Unicorn.AddOverlay( "voteR2", "voteR2", -1000, -1000 ) );
        tpVote.forEach( x => x.visible = false );
        voteStar = Unicorn.AddOverlay( "star", "star", -1000, -1000 );
        voteText = Unicorn.AddText( "bubbleText", "!power   !heal   !speed", 120, 35, {
          fontFamily: "Geo",
          fontSize: 24,
          fontWeight: 'bold',
          fill: "#051155"
        });
        voteText.anchor.set( 0.5 );
        voteText.visible = false;
        voteTimeBar = Unicorn.AddOverlay( "timerBar", "timerBar", -1000, 0 );
        speechBubbles.push( Unicorn.AddOverlay( "speechL", "speechL", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechR", "speechR", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechLongL", "speechLongL", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechLongR", "speechLongR", -1000, 0 ) );
        speechBubbles.forEach( x => x.visible = false );
        speechBubbleText = Unicorn.AddText( "bubbleText", "Taste my rainbow!", 120, 55, {
          fontFamily: "Geo",
          fontSize: 24,
          fontWeight: 'bold',
          fill: "#051155"
        });
        speechBubbleText.anchor.set( 0.5 );
        speechBubbleText.visible = false;

        upgradeImages.push( Unicorn.AddOverlay( "powerup", "powerup", -1000, 0 ) );
        upgradeImages.push( Unicorn.AddOverlay( "speedup", "speedup", -1000, 0 ) );
        upgradeImages.push( Unicorn.AddOverlay( "healup", "healup", -1000, 0 ) );
        upgradeImages.forEach( u => u.anchor.set( 0.5 ) );
        // Unicorn.AddDetector( "detect", {
        //   type: "rectangle",
        //   x: 64, y: 300,
        //   width: 128, height: 128
        // }, ( label, body ) => {
        //   console.log( "Enter:", label, body );
        //   Unicorn.PlaySound( "fart", {
        //     volume: 0.25
        //   } );
        // }, ( label, body ) => {
        //   console.log( "Exit:", label, body );
        // } );
      }

      function Update( timestamp, timeDiffInMs ) {
        // Add Update Loop
        if( tpHP > 0 ) {
          tpImage.x = tpTrike.position.x;
          tpImage.y = tpTrike.position.y;
          var dirX = Math.cos( tpTrike.angle );
          var dirY = Math.sin( tpTrike.angle );
          tpExhaust.forEach( ( e, i ) => {
            e.transform.rotation = tpTrike.angle;
            e.transform.scale.x = 0.5 + Math.sin( timestamp / 1000 * 20 + i * 5 ) * 0.1;
            e.transform.scale.y = 0.5 + Math.cos( timestamp / 1000 * 20 + i * 10 ) * 0.05;
            e.x = tpTrike.position.x - dirX * 50;
            e.y = tpTrike.position.y - dirY * 50;
          });
        }
        else if( tpDeathTimer > 0 ) {
          tpDeathTimer -= timeDiffInMs;
          var progress = 1 - tpDeathTimer / 1500;
          tpImage.x = tpTrike.position.x + 50 * Math.cos( progress * 3 ) - 50;
          tpImage.y = tpTrike.position.y - 100 * Math.sin( progress * 3 );
          tpImage.transform.rotation = progress * 10;
          tpImage.transform.scale.x = 1 + Math.sin( progress * 3 );
          tpImage.transform.scale.y = 1 + Math.sin( progress * 3 );
          tpExhaust.forEach( ( e, i ) => e.x = -1000 );
        }
        // Move Hearts to above Teapup
        for( var i = 0; i < tpMaxHP; i++ ) {
          var pX = tpImage.x - 80 - 20;
          var pY = tpImage.y - 110;
          tpEmptyHearts[ i ].position.x = pX + 40 * i;
          tpEmptyHearts[ i ].position.y = pY;
          tpFullHearts[ i ].position.x = pX + 40 * i;
          tpFullHearts[ i ].position.y = pY;
        }

        voteText.visible = false;

        if( gameState === "start" ) {
          if( introTextTimer > 0 ) {
            introTextTimer -= timeDiffInMs;
            if( introTextTimer <= 0 ) {
              introText++;
              if( params.get( "channel" ) ) {
                if( introText >= teapupIntro.length ) {
                  introText = teapupIntro.length - 1;
                }
                showSpeechBubble( teapupIntro[ introText ] );
                introTextTimer = 5000;
              }
              else {
                if( introText >= teapupHelp.length ) {
                  introText = teapupHelp.length - 1;
                }
                showSpeechBubble( teapupHelp[ introText ] );
                introTextTimer = 5000;
              }
            }
          }

          driveTeapup( timeDiffInMs );
          aimTeapup( timeDiffInMs );
        }

        if( gameState === "win" ) {
          if( titleTimer > 0 ) {
            titleTimer -= timeDiffInMs;
            titleWin.x = 640;
            titleWin.y = -500 + ( 1 - titleTimer / 1000 ) * 860;
            if( titleTimer < 0 ) {
              titleWin.y = 360;
            }
          }

          if( winTextTimer > 0 ) {
            winTextTimer -= timeDiffInMs;
            if( winTextTimer <= 0 ) {
              winText++;
              if( winText < teapupWin.length ) {
                showSpeechBubble( teapupWin[ winText ] );
                winTextTimer = 4000;
              }
              else if( winText - teapupWin.length < credits.length ) {
                showSpeechBubble( credits[ winText - teapupWin.length ] );
                winTextTimer = 4000;
              }
              else {
                winTextTimer = 0;
                setTimeout( () => {
                  location.reload();
                }, 5000 );
              }
            }
          }
        }

        if( gameState === "vote" ) {
          if( voteTimer > 0 ) {
            voteTimer -= timeDiffInMs;
            voteTimeBar.transform.scale.x = voteTimer / voteTime;
          }

          driveTeapup( timeDiffInMs );
          aimTeapup( timeDiffInMs );

          var power = votePower, speed = voteSpeed, heal = voteHeal;
          Object.keys( votes ).forEach( v => {
            switch( votes[ v ] ) {
              case "power": power++; break;
              case "speed": speed++; break;
              case "heal": heal++; break;
            }
          } );
          var maxVotes = Math.max( power, Math.max( speed, heal ) );

          voteText.visible = true;
          var offsetY = 0, offsetTextY = 0;
          var textIndex = 0;
          if( tpTrike.position.y < 200 ) {
            offsetY = 160;
            offsetTextY = 8;
            textIndex = 2;
          }
          tpVote.forEach( s => s.visible = false );
          if( tpTrike.position.x < 300 ) {
            tpVote[ textIndex + 1 ].visible = true;
            tpVote[ textIndex + 1 ].x = tpTrike.position.x + 30;
            tpVote[ textIndex + 1 ].y = tpTrike.position.y - 120 + offsetY;
            voteText.x = tpVote[ textIndex + 1 ].x + 120;
            voteText.y = tpVote[ textIndex + 1 ].y + 40 + offsetTextY;
            voteTimeBar.x = tpVote[ textIndex + 1 ].x + 10;
            voteTimeBar.y = tpVote[ textIndex + 1 ].y + 79 + offsetTextY;
          }
          else {
            tpVote[ textIndex + 0 ].visible = true;
            tpVote[ textIndex + 0 ].x = tpTrike.position.x - 300;
            tpVote[ textIndex + 0 ].y = tpTrike.position.y - 140 + offsetY;
            voteText.x = tpVote[ textIndex + 0 ].x + 120;
            voteText.y = tpVote[ textIndex + 0 ].y + 40 + offsetTextY;
            voteTimeBar.x = tpVote[ textIndex + 0 ].x + 9;
            voteTimeBar.y = tpVote[ textIndex + 0 ].y + 79 + offsetTextY;
          }
          if( power === maxVotes ) {
            voteStar.x = voteText.x - 83;
            voteStar.y = voteText.y - 65;
          }
          else if( speed === maxVotes ) {
            voteStar.x = voteText.x + 62;
            voteStar.y = voteText.y - 65;
          }
          else {
            voteStar.x = voteText.x - 10;
            voteStar.y = voteText.y - 65;
          }
          if( tpHP === 1 ) {
            // Auto-Select Heal
            voteTimer = 0;
            tpHP += 3;
            refreshVisibleHP();
            console.log( "Auto-Heal" );
            winningUpgrade = 2;
            upgradeAnimTimer = 2000;
            voteTimeBar.x = -1000;
            voteStar.x = -1000;
            startBattle();
          }
          else if( voteTimer <= 0 ) {
            console.log( "Power:", power );
            console.log( "Speed:", speed );
            console.log( "Heal:", heal );
            voteStar.x = -1000;
            if( power === maxVotes ) {
              console.log( "POWER UP" );
              firingCount += 3;
              tpHP--;
              refreshVisibleHP();
              winningUpgrade = 0;
            }
            else if( speed === maxVotes ) {
              console.log( "SPEED UP" );
              numFiringRateUpgrades++;
              firingRate *= 1 - 1 / numFiringRateUpgrades;
              // firingRate *= 0.5;
              tpSpeed += 0.5;
              tpHP--;
              refreshVisibleHP();
              winningUpgrade = 1;
            }
            else {
              console.log( "HEAL UP" );
              if( tpHP < tpMaxHP ) {
                tpHP += 3;
                if( tpHP > tpMaxHP ) {
                  tpHP = tpMaxHP;
                }
                refreshVisibleHP();
              }
              winningUpgrade = 2;
            }
            upgradeAnimTimer = 2000;
            voteTimeBar.x = -1000;
            startBattle();
          }
        }
        else {
          var scaleY = 1, offsetY = 0, offsetTextY = 0;
          if( tpTrike.position.y < 200 ) {
            scaleY = -1;
            offsetY = 280;
            offsetTextY = -113;
          }
          if( isSpeechBubbleShowing ) {
            var textIndex = isLongSpeechText ? 2 : 0;
            var textOffset = isLongSpeechText ? 80 : 0;
            speechBubbleText.visible = true;
            speechBubbles.forEach( s => s.visible = false );
            if( isLongSpeechText ) {
              if( tpTrike.position.x < 500 ) {
                speechBubbles[ textIndex + 1 ].scale.y = scaleY;
                speechBubbles[ textIndex + 1 ].visible = true;
                speechBubbles[ textIndex + 1 ].x = tpImage.x + 30;
                speechBubbles[ textIndex + 1 ].y = tpImage.y - 120 + offsetY;
                speechBubbleText.x = speechBubbles[ textIndex + 1 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 1 ].y + 55 + offsetTextY;
              }
              else {
                speechBubbles[ textIndex + 0 ].scale.y = scaleY;
                speechBubbles[ textIndex + 0 ].visible = true;
                speechBubbles[ textIndex + 0 ].x = tpImage.x - 440;
                speechBubbles[ textIndex + 0 ].y = tpImage.y - 140 + offsetY;
                speechBubbleText.x = speechBubbles[ textIndex + 0 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 0 ].y + 55 + offsetTextY;
              }
            }
            else {
              if( tpTrike.position.x < 300 ) {
                speechBubbles[ textIndex + 1 ].scale.y = scaleY;
                speechBubbles[ textIndex + 1 ].visible = true;
                speechBubbles[ textIndex + 1 ].x = tpImage.x + 30;
                speechBubbles[ textIndex + 1 ].y = tpImage.y - 120 + offsetY;
                speechBubbleText.x = speechBubbles[ textIndex + 1 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 1 ].y + 55 + offsetTextY;
              }
              else {
                speechBubbles[ textIndex + 0 ].scale.y = scaleY;
                speechBubbles[ textIndex + 0 ].visible = true;
                speechBubbles[ textIndex + 0 ].x = tpImage.x - 300;
                speechBubbles[ textIndex + 0 ].y = tpImage.y - 140 + offsetY;
                speechBubbleText.x = speechBubbles[ textIndex + 0 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 0 ].y + 55 + offsetTextY;
              }
            }
          }
        }

        if( gameState === "battle" ) {
          tpVote.forEach( x => x.visible = false );
          if( shieldTimer > 0 ) {
            shieldTimer -= timeDiffInMs;
            tpTrike.sprite.alpha = tpImage.alpha = 0.75 + Math.sin( timestamp / 100 ) * 0.5;
            tpImage.tint = lerpColor( 0xff0000, 0xffffff, Math.min( tpImage.alpha, 1 ) );
          }
          else {
            tpTrike.sprite.alpha = tpImage.alpha = 1;
            tpImage.tint = 0xffffff;
          }

          if( upgradeAnimTimer > 0 ) {
            upgradeAnimTimer -= timeDiffInMs;
            var animProgress = upgradeAnimTimer / 2000;
            upgradeImages[ winningUpgrade ].x = tpTrike.position.x;
            upgradeImages[ winningUpgrade ].y = tpTrike.position.y - 240 + animProgress * 240;
            upgradeImages[ winningUpgrade ].alpha = animProgress;
            if( upgradeAnimTimer <= 0 ) {
              upgradeImages[ winningUpgrade ].x = -1000;
            }
          }

          if( isBossLevel ) {
            bossTimer -= timeDiffInMs;
            if( bossTimer < 0 ) {
              bossTimer = 10000;
              spawnEnemyWave( Math.floor( bossEndLevel * 1.5 ) );
            }
            if( Math.floor( timestamp / 1000 ) % 2 == 0 ) {
              bosscat[ 0 ].x = 640;
              bosscat[ 0 ].y = 360;
              bosscat[ 1 ].x = -1000;
            }
            else {
              bosscat[ 1 ].x = 640;
              bosscat[ 1 ].y = 360;
              bosscat[ 0 ].x = -1000;
            }
            bossHealthBarContainer.x = 540;
            bossHealthBarContainer.y = 260;
            bossHealthBar.x = 540;
            bossHealthBar.y = 260;
            bossHealthBar.transform.scale.x = bossHP / bossMaxHP;
          }

          if( isSpawningEnemies ) {
            warpSize += timeDiffInMs / 1000 * 2;
            if( warpSize > 1 ) {
              warpSize = 1;
            }
          }
          else if( warpSize > 0 ) {
            warpSize -= timeDiffInMs / 1000 * 2;
          }
          else {
            warpSize = 0;
          }

          if( warpSize > 0 ) {
            warpDark.transform.scale.x = warpDark.transform.scale.y = warpSize + Math.sin( timestamp / 21 ) * 0.05;
            warpLight.transform.scale.x = warpLight.transform.scale.y = warpSize + Math.sin( timestamp / 22 ) * 0.05;
          }
          else {
            warpDark.transform.scale.x = warpDark.transform.scale.y = 0;
            warpLight.transform.scale.x = warpLight.transform.scale.y = 0;
          }
          warpDark.transform.rotation = -timestamp / 100 * 0.81236;
          warpLight.transform.rotation = -timestamp / 100 * 0.576273;

          // Spawn enemies when the current wave is defeated
          if( !isSpawningEnemies ) {
            if( waveNumber < waveCount ) {
              waveNumber++;
              console.log( "WAVE:", waveNumber );
              spawnEnemyWave( ( enemyLevel - 1 ) * 2 + roundNumber );
            }
            else if( enemies.length <= 0 && !isBossLevel ) {
              startVote();
            }
          }

          fireTime += timeDiffInMs;
          if( fireTime > firingRate ) {
            fireTime -= firingRate;
            for( var i = 0; i < firingCount; i++ ) {
              shootSkittle();
            }
          }

          driveTeapup( timeDiffInMs );
          aimTeapup( timeDiffInMs );

          skittles.forEach( (x, i) => {
            x.life -= timeDiffInMs;
            if( x.life <= 0 ) {
              // We've hit the ground
              skittles.splice( i, 1 );
              Unicorn.RemoveObject( x.label );
            }
          });

          enemies.forEach( ( x, i ) => {
            var dX = tpTrike.position.x - x.position.x;
            var dY = tpTrike.position.y - x.position.y;
            var length = Math.sqrt( dX * dX + dY * dY );
            // console.log( x );
            x.angle = Math.atan2( dY, dX );
            Matter.Body.setVelocity( x, { x: dX / length * x.moveSpeed, y: dY / length * x.moveSpeed });
          });
        }
      }

      function refreshVisibleHP() {
        for( var i = 0; i < tpFullHearts.length; i++ ) {
          // Only show upto the amount of life Teapup has
          tpFullHearts[ i ].visible = i < tpHP;
        }
      }

      function OnChatCommand( user, command, message, flags ) {
        // Handle Chat Commands
        if( gameState === "start" ) {
          switch( command ) {
            case "candytime":
              switch( message.toLowerCase() ) {
                case "easy":
                  bossMaxHP = 100;
                  bossEndLevel = 2;
                  break;
                case "hard":
                  bossMaxHP = 5000;
                  bossEndLevel = 9;
                  break;
                default:
                  bossMaxHP = 1000;
                  bossEndLevel = 5;
                  break;
              }
              startVote();
              break;
          }
        }
        else if( gameState === "vote" ) {
          switch( command ) {
            case "power":
            case "speed":
            case "heal":
              // Add to tally
              console.log( user + " voted " + command );
              votes[ user ] = command;
              break;
            case "gogogo":
            case "next":
              if( flags.broadcaster || flags.mod ) {
                voteTimer = 100;
              }
              break;
          }
        }
        else if( gameState === "win" ) {
          switch( command ) {
            case "skip":
            case "reset":
            case "candytime":
              location.reload();
              break;
            default:
              break;
          }
        }
      }

      function LoadAssets() {
        Unicorn.Load( "heart_empty", "assets/heartEmpty.png" );
        Unicorn.Load( "heart_full", "assets/heartFull.png" );
        Unicorn.Load( "skittleBlue", "assets/skittleBlue.png" );
        Unicorn.Load( "skittleGreen", "assets/skittleGreen.png" );
        Unicorn.Load( "skittlePurple", "assets/skittlePurple.png" );
        Unicorn.Load( "skittleRed", "assets/skittleRed.png" );
        Unicorn.Load( "skittleViolet", "assets/skittleViolet.png" );
        Unicorn.Load( "skittleYellow", "assets/skittleYellow.png" );
        Unicorn.Load( "exhaustBlue", "assets/exhaustBlue.png" );
        Unicorn.Load( "exhaustGreen", "assets/exhaustGreen.png" );
        Unicorn.Load( "exhaustPurple", "assets/exhaustPurple.png" );
        Unicorn.Load( "exhaustRed", "assets/exhaustRed.png" );
        Unicorn.Load( "exhaustViolet", "assets/exhaustViolet.png" );
        Unicorn.Load( "exhaustYellow", "assets/exhaustYellow.png" );
        Unicorn.Load( "powerup", "assets/powerup.png" );
        Unicorn.Load( "speedup", "assets/speedup.png" );
        Unicorn.Load( "healup", "assets/healup.png" );
        Unicorn.Load( "warpDark", "assets/warpDark.png" );
        Unicorn.Load( "warpLight", "assets/warpLight.png" );
        Unicorn.Load( "robot", "assets/robot.png" );
        Unicorn.Load( "drone", "assets/drone.png" );
        Unicorn.Load( "tank", "assets/tank.png" );
        Unicorn.Load( "tricycle", "assets/teapupTrike.png" );
        Unicorn.Load( "teapup", "assets/teapup.png" );
        Unicorn.Load( "star", "assets/star.png" );
        Unicorn.Load( "voteL", "assets/voteBubbleL.png" );
        Unicorn.Load( "voteR", "assets/voteBubbleR.png" );
        Unicorn.Load( "voteL2", "assets/voteBubbleL2.png" );
        Unicorn.Load( "voteR2", "assets/voteBubbleR2.png" );
        Unicorn.Load( "speechL", "assets/speechBubbleL.png" );
        Unicorn.Load( "speechR", "assets/speechBubbleR.png" );
        Unicorn.Load( "speechLongL", "assets/speechBubbleLongL.png" );
        Unicorn.Load( "speechLongR", "assets/speechBubbleLongR.png" );
        Unicorn.Load( "timerBar", "assets/timerBar.png" );
        Unicorn.Load( "bosscat1", "assets/catastrophe1.png" );
        Unicorn.Load( "bosscat2", "assets/catastrophe2.png" );
        Unicorn.Load( "healthBar", "assets/healthBarFull.png" );
        Unicorn.Load( "healthBarContainer", "assets/healthBarEmpty.png" );
        Unicorn.Load( "titleWin", "assets/TitleWin.png" );
      }

      function OnChatMessage( user, message, flags, self ) {
        // Handle Chat Messages
        console.log( message );
      }

      function getRandomInt( max ) {
        return Math.floor( Math.random() * Math.floor( max ) );
      }

      // window.addEventListener('load', () => {
      // });

      function CreateGame() {
        Unicorn.Create( "unicorn-display", {
          width: 1280,
          height: 720,
          background: params.get( "overlay" ) ? "transparent" : 0x777777,
          // background: "transparent",
          init: Init,
          update: Update,
          channel: params.get( "channel" ),
          onCommand: OnChatCommand,
          onChat: OnChatMessage,
          // screenWalls: false, // Default: true
          // wallBottom: true,
          gravity: { x: 0, y: 0 },
          // gravity: { x: 0, y: 2 } // Default: { x: 0, y: 1 }
        });
      }
    </script>
  </body>
</html>
