<html>
  <head>
    <title>Rainbow Rampage</title>
    <link rel='stylesheet' href='unicorn.css' />
    <script src="pinkfluffyunicorn.min.js"></script>
    <script src="brain.min.js"></script>
  </head>
  <body>
    <div id="unicorn-display"></div>
    <script>
      window.WebFontConfig = {
          google: {
              families: ['Luckiest Guy', 'Geo'],
          },
          active() {
              CreateGame();
          },
      };

      /* eslint-disable */
      // include the web-font loader script
      (function() {
          const wf = document.createElement('script');
          wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'
          }://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;
          wf.type = 'text/javascript';
          wf.async = 'true';
          const s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(wf, s);
      }());
      /* eslint-enabled */

      var teapupQuotes = [
        "TASTE MY RAINBOW MOMMAPUPPERS!!",
        "Skittle, skedaddle.",
        "Vroom vroom.. to your DOOM!",
        "NO HALLOWEEN MAKES TPUP HANGRY!",
        "This one is for Prof. Fluffington!",
        // "I'll be back!",
        "Winner Winner Skittles Dinner",
      ];

      var gameState = "vote"; // vote, battle, end
      var counter = 0;
      var tpTrike = null;
      var tpExhaust = [];
      var tpEmptyHearts = [];
      var tpFullHearts = [];
      const tpMaxHP = 5;
      var tpHP = 1;
      var tpAngle = 0;
      var tpSpeed = 2;
      var tpAimAngle = 0;
      var tpImage;
      var tpVote = [];
      var voteStar;
      var voteText;
      var upgradeImages = [];
      var winningUpgrade = 0;
      var upgradeAnimTimer = 0;
      var speechBubbles = [];
      var speechBubbleText;
      var isLongSpeechText = false;
      var isSpeechBubbleShowing = false;
      var shieldTime = 2000;
      var shieldTimer = 0;
      // 3 waves per round, 3 rounds before a boss
      var roundCount = 3;
      var roundNumber = 0;
      var warpDark, warpLight;
      var isSpawningEnemies = false;
      var warpSize = 0;
      var waveCount = 3;
      var waveNumber = 0;
      var enemyLevel = 1;
      var enemies = [];
      var hpText = null;
      var firingRate = 2000;
      var firingCount = 1;
      var numFiringRateUpgrades = 1;
      var fireTime = 0;
      var skittles = [];
      var voteTime = 30000;
      var voteTimer = 0;
      var voteTimeBar;
      var votes = {};
      var votePower = Math.random() * 0.1, voteSpeed = Math.random() * 0.1, voteHeal = Math.random() * 0.1;

      function startVote() {
        gameState = "vote";
        voteTimer = voteTime;
        votes = {};
        votePower = Math.random() * 0.1;
        voteSpeed = Math.random() * 0.1;
        voteHeal = Math.random() * 0.1;
        console.log( "Vote: !power !speed !heal" );
        waveNumber = 0;
        roundNumber++;
        console.log( "ROUND:", roundNumber );
        if( roundNumber >= roundCount ) {
          // TODO: BOSS TIME!
          roundNumber = 0;
          enemyLevel++;
        }
        speechBubbles.forEach( s => s.visible = false );
        speechBubbleText.visible = false;
        tpImage.alpha = 1;
        tpImage.tint = 0xffffff;
      }

      function showSpeechBubble( text ) {
        isSpeechBubbleShowing = true;
        isLongSpeechText = text.length > 20;
        if( text.length >= 35 ) {
          text = text.slice( 0, 33 ) + "..";
        }
        speechBubbleText.visible = true;
        setTimeout( () => {
          isSpeechBubbleShowing = false;
          speechBubbleText.visible = false;
          speechBubbles.forEach( x => x.visible = false );
        }, 3000 );
        speechBubbleText.text = text;
      }

      function startBattle() {
        gameState = "battle";
      }

      function endGame() {
        gameState = "end";
        tpTrike.isStatic = true;
        tpImage.alpha = 1;
        tpImage.tint = 0xffffff;
      }

      function aiCompute( rayVals ) {
        var rayMax = 0;
        var numCasts = rayVals.length;
        for( var i = 0; i < numCasts; i++ ) {
          var factor = i / ( numCasts - 1 );
          var mid = ( numCasts - 1 ) / 2;
          var change = ( mid - Math.abs( i - mid ) ) / mid;
          rayMax += 120 * change + 70;
        }
        var total = 0, leftTotal = 0, rightTotal = 0;
        for( var i = 0, len = rayVals.length / 2; i < len; i++ ) {
          leftTotal += rayVals[ i ];
        }
        for( var i = Math.floor( rayVals.length / 2 ), len = rayVals.length; i < len; i++ ) {
          rightTotal += rayVals[ i ];
        }
        total = rayVals.reduce( (a, b) => a + b );
        var pikaState;
        if( total > 0 && total < rayMax - 10 ) {
          if( total < rayMax / 2 ) { // Too close to everything so try and turn left
            pikaState = "left";
          }
          else if( leftTotal > rightTotal ) {
            pikaState = "left";
          }
          else {
            pikaState = "right";
          }
        }
        else {
          pikaState = "idle";
        }
        // console.log( pikaState );
        switch( pikaState ) {
          case "left":
            return -90;
          case "right":
            return 90;
          case "idle":
          default:
            return 0;
        }
      }

      function aimTeapup( timeDiff ) {
        var closestEnemy = -1, closestDist = 1000000;
        var pX = tpTrike.position.x, pY = tpTrike.position.y;
        enemies.forEach( (x, i) => {
          var dX = x.position.x - pX, dY = x.position.y - pY;
          var dist = dX * dX + dY * dY;
          if( dist < closestDist ) {
            closestEnemy = i;
            closestDist = dist;
          }
        });
        if( closestEnemy >= 0 ) {
          var enemy = enemies[ closestEnemy ];
          var dX = enemy.position.x - pX, dY = enemy.position.y - pY;
          tpAimAngle = Math.atan2( dY, dX );
        }
        // else {
        //   // Turn towards where Teapup is moving
        //   tpAimAngle = tpAngle;
        // }
        tpImage.transform.rotation = tpAimAngle;
      }

      function driveTeapup( timeDiff ) {
        var rayVals = [];
        var numCasts = 51;
        for( var i = 0; i < numCasts; i++ ) {
          var factor = i / ( numCasts - 1 );
          var mid = ( numCasts - 1 ) / 2;
          var change = ( mid - Math.abs( i - mid ) ) / mid;
          var dirX = Math.cos( tpAngle - Math.PI /2 + Math.PI * factor );
          var dirY = Math.sin( tpAngle - Math.PI /2 + Math.PI * factor );
          var rayLength = 120 * change + 70;
          var rayCast = Unicorn.Raycast( { x: tpTrike.position.x + dirX * 60, y: tpTrike.position.y + dirY * 60 }, { x: tpTrike.position.x + dirX * rayLength, y: tpTrike.position.y + dirY * rayLength } );
          if( rayCast.length > 0 ) {
            var obstacle = rayCast.find( b => !b.body.label.startsWith( "skittle" ) );
            if( obstacle ) {
              rayLength = obstacle.depth;
            }
          }
          rayVals.push( rayLength );
        }
        var turnAngle = aiCompute( rayVals ) * timeDiff / 1000;
        const maxAngle = 30;
        if( turnAngle < -maxAngle ) {
          turnAngle = -maxAngle;
        }
        else if( turnAngle > maxAngle ) {
          turnAngle = maxAngle;
        }
        // console.log( tpTrike.angle + " + " + turnAngle * ( 2 * Math.PI / 360 ) );
        tpAngle += turnAngle * ( 2 * Math.PI / 360 );
        if( tpAngle < -Math.PI * 2 ) {
          tpAngle += Math.PI * 2;
        }
        if( tpAngle > Math.PI * 2 ) {
          tpAngle -= Math.PI * 2;
        }
        tpTrike.angle = tpAngle;
        // console.log( tpTrike );
        Matter.Body.setVelocity( tpTrike, { x: Math.cos( tpAngle ) * tpSpeed, y: Math.sin( tpAngle ) * tpSpeed } );
      }

      function shootSkittle() {
        var dirX = Math.cos( tpAimAngle );
        var dirY = Math.sin( tpAimAngle );
        var sX = tpTrike.position.x + dirX * 60;
        var sY = tpTrike.position.y + dirY * 60;
        var bulletX = Math.cos( tpAimAngle + Math.random() * -0.005 + 0.0005 );
        var bulletY = Math.sin( tpAimAngle + Math.random() * -0.005 + 0.0005 );
        var color = getRandomInt( 6 );
        var sprite = "skittleBlue";
        switch( color ) {
          case 0:
            color = 0x1474bb;
            sprite = "skittleBlue";
            break;
          case 1:
            color = 0xe41e26;
            sprite = "skittleRed";
            break;
          case 2:
            color = 0x8fc33e;
            sprite = "skittleGreen";
            break;
          case 3:
            color = 0x5d2b7d;
            sprite = "skittlePurple";
            break;
          case 4:
            color = 0xfeee22;
            sprite = "skittleYellow";
            break;
          case 5:
            color = 0xa72d89;
            sprite = "skittleViolet";
            break;
        }
        var skittle = Unicorn.AddObject( "skittle" + counter++, {
              type: "circle",
              x: sX, y: sY,
              radius: 8,
              sprite: sprite,
              bounce: 0,
            } );
        skittle.force.x = bulletX * 0.01;
        skittle.force.y = bulletY * 0.01;
        skittle.life = 500;
        skittle.color = color;
        skittles.push( skittle );
      }

      function spawnTeapup( x, y, health ) {
        tpHP = health;
        tpExhaust.push( Unicorn.AddOverlay( "exhaustRed", "exhaustRed", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustBlue", "exhaustBlue", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustYellow", "exhaustYellow", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustViolet", "exhaustViolet", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustGreen", "exhaustGreen", x, y ) );
        tpExhaust.push( Unicorn.AddOverlay( "exhaustPurple", "exhaustPurple", x, y ) );
        tpExhaust.forEach( e => {
          e.anchor.set( 0.5 );
        });
        tpTrike = Unicorn.AddObject( "tricycle", {
          type: "circle",
          x, y,
          radius: 60,
          sprite: "tricycle",
          bounce: 0.9,
          onEnter: ( label, body ) => {
            if( label.startsWith( "enemy" ) ) {
              // We hit a new enemy!
              if( shieldTimer <= 0 ) {
                console.log( "ouch cheese!" );
                tpHP--;
                refreshVisibleHP();
                if( tpHP <= 0 ) {
                  // GAME OVER!!!
                  console.log( "GAME OVER" );
                  endGame();
                }
                else {
                  shieldTimer = shieldTime;
                }
              }
            }
          }
        } );
        tpImage = Unicorn.AddOverlay( "teapup", "teapup", x, y );
        tpImage.anchor.set( 0.5 );
      }

      function spawnEnemy( x, y, health, speed ) {
        let enemy = Unicorn.AddObject( "enemy" + counter++, {
          type: "rectangle",
          x, y,
          width: 50, height: 50,
          sprite: "robot",
          bounce: 0,
          onEnter: ( label, body ) => {
            // Check for bullets!
            if( label.startsWith( "skittle" ) ) {
              // KABOOM
              let candyPieces = Unicorn.AddParticles( "candy" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: body.color,
                  endColor: body.color,
                  blendMode: PIXI.BLEND_MODES.OVERLAY,
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.1,
                  maxSpeed: 0.25,
                  decay: 1, // Scale from 0 - 10
                }, body.position.x, body.position.y );
              setTimeout( () => {
                  Unicorn.RemoveParticles( candyPieces.name );
                }, 100 );
              // console.log( body );
              // Remove Skittle
              var skittleIndex = skittles.findIndex( s => s.label === label );
              if( skittleIndex >= 0 ) {
                skittles.splice( skittleIndex, 1 );
              }
              Unicorn.RemoveObject( label );
              enemy.health--;
              if( enemy.health <= 0 ) {
                // DED ENEMY
                let explosion = Unicorn.AddParticles( "explosion" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: "#FB8200",
                  endColor: "#FEBE79",
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.1,
                  maxSpeed: 0.25,
                  decay: 1, // Scale from 0 - 10
                }, enemy.position.x, enemy.position.y );
                let pieces = Unicorn.AddParticles( "pieces" + counter++, {
                  shape: "circle", // "cone", "line"
                  startColor: "#4A4957",
                  endColor: "#4A4957",
                  blendMode: PIXI.BLEND_MODES.DARKEN,
                  intensity: 10, // Scale from 1 - 10
                  minSpeed: 0.01,
                  maxSpeed: 0.025,
                  decay: 1, // Scale from 0 - 10
                }, enemy.position.x, enemy.position.y );
                setTimeout( () => {
                  Unicorn.RemoveParticles( explosion.name );
                  Unicorn.RemoveParticles( pieces.name );
                }, 100 );
                enemies.splice( enemies.indexOf( enemy ), 1 );
                Unicorn.RemoveObject( enemy.label );
              }
            }
          }
        } );
        enemy.health = health;
        enemy.moveSpeed = speed;
        enemies.push( enemy );
      }

      function spawnEnemyWave( size ) {
        // TODO: Add multiple types of enemies
        // Select a warp spot away from Teapup
        let x = getRandomInt( 640 ), y = getRandomInt( 360 );
        if( tpTrike.position.x < 640 ) {
          x += 640;
        }
        if( tpTrike.position.y < 360 ) {
          y += 360;
        }
        warpSize = 0;
        isSpawningEnemies = true;
        warpDark.x = x; warpDark.y = y;
        warpLight.x = x; warpLight.y = y;
        warpDark.transform.scale.x = warpDark.transform.scale.y = warpSize;
        warpLight.transform.scale.x = warpLight.transform.scale.y = warpSize;
        setTimeout( () => {
          isSpawningEnemies = false;
          for( var i = 0; i < size; i++ ) {
            spawnEnemy( x + Math.random() * 10, y + Math.random() * 10, ( enemyLevel - 1 ) * 2 + 1, 1 );
          }
        }, 500 );
        // let spawner = setInterval( () => {
        //   size--;
        //   if( size <= 0 ) {
        //     clearInterval( spawner );
        //   }
          
        // }, 500 );
      }

      function Init() {
        // Add Initialization Here
        Unicorn.Load( "heart_empty", "assets/heartEmpty.png" );
        Unicorn.Load( "heart_full", "assets/heartFull.png" );
        Unicorn.Load( "skittleBlue", "assets/skittleBlue.png" );
        Unicorn.Load( "skittleGreen", "assets/skittleGreen.png" );
        Unicorn.Load( "skittlePurple", "assets/skittlePurple.png" );
        Unicorn.Load( "skittleRed", "assets/skittleRed.png" );
        Unicorn.Load( "skittleViolet", "assets/skittleViolet.png" );
        Unicorn.Load( "skittleYellow", "assets/skittleYellow.png" );
        Unicorn.Load( "exhaustBlue", "assets/exhaustBlue.png" );
        Unicorn.Load( "exhaustGreen", "assets/exhaustGreen.png" );
        Unicorn.Load( "exhaustPurple", "assets/exhaustPurple.png" );
        Unicorn.Load( "exhaustRed", "assets/exhaustRed.png" );
        Unicorn.Load( "exhaustViolet", "assets/exhaustViolet.png" );
        Unicorn.Load( "exhaustYellow", "assets/exhaustYellow.png" );
        Unicorn.Load( "powerup", "assets/powerup.png" );
        Unicorn.Load( "speedup", "assets/speedup.png" );
        Unicorn.Load( "healup", "assets/healup.png" );
        Unicorn.Load( "warpDark", "assets/warpDark.png" );
        Unicorn.Load( "warpLight", "assets/warpLight.png" );
        Unicorn.Load( "robot", "assets/robot.png" );
        Unicorn.Load( "tricycle", "assets/teapupTrike.png" );
        Unicorn.Load( "teapup", "assets/teapup.png" );
        Unicorn.Load( "star", "assets/star.png" );
        Unicorn.Load( "voteL", "assets/voteBubbleL.png" );
        Unicorn.Load( "voteR", "assets/voteBubbleR.png" );
        Unicorn.Load( "speechL", "assets/speechBubbleL.png" );
        Unicorn.Load( "speechR", "assets/speechBubbleR.png" );
        Unicorn.Load( "speechLongL", "assets/speechBubbleLongL.png" );
        Unicorn.Load( "speechLongR", "assets/speechBubbleLongR.png" );
        Unicorn.Load( "timerBar", "assets/timerBar.png" );
        // Unicorn.AddText( "title", "Rainbow Rampage", 50, 50, {
        //   fontFamily: "Luckiest Guy",
        //   fontSize: 120,
        //   // fontWeight: 'bold',
        //   fill: "#000000"
        // });
        warpLight = Unicorn.AddOverlay( "warpLight", "warpLight", -1000, -1000 );
        warpDark = Unicorn.AddOverlay( "warpDark", "warpDark", -1000, -1000 );
        warpLight.anchor.set( 0.5 );
        warpDark.anchor.set( 0.5 );
        for( var i = 0; i < tpMaxHP; i++ ) {
          tpEmptyHearts.push( Unicorn.AddOverlay( "heart_empty" + i, "heart_empty", 100, 100 ) );
          tpFullHearts.push( Unicorn.AddOverlay( "heart_full" + i, "heart_full", 100, 100 ) );
        }
        // hpText = Unicorn.AddText( "health", tpHP, 300, 500, {
        //   fontFamily: 'Bubblegum Sans',
        //   fontSize: 36,
        //   fontWeight: 'bold',
        //   fill: "#000000"
        // });
        spawnTeapup( 640, 360, tpMaxHP );
        voteStar = Unicorn.AddOverlay( "star", "star", -1000, -1000 );
        tpVote.push( Unicorn.AddOverlay( "voteL", "voteL", -1000, -1000 ) );
        tpVote.push( Unicorn.AddOverlay( "voteR", "voteR", -1000, -1000 ) );
        tpVote.forEach( x => x.visible = false );
        voteText = Unicorn.AddText( "bubbleText", "!power   !heal   !speed", 120, 35, {
          fontFamily: "Geo",
          fontSize: 24,
          fontWeight: 'bold',
          fill: "#051155"
        });
        voteText.anchor.set( 0.5 );
        voteText.visible = false;
        voteTimeBar = Unicorn.AddOverlay( "timerBar", "timerBar", -1000, 0 );
        speechBubbles.push( Unicorn.AddOverlay( "speechL", "speechL", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechR", "speechR", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechLongL", "speechLongL", -1000, 0 ) );
        speechBubbles.push( Unicorn.AddOverlay( "speechLongR", "speechLongR", -1000, 0 ) );
        speechBubbles.forEach( x => x.visible = false );
        speechBubbleText = Unicorn.AddText( "bubbleText", "Taste my rainbow!", 120, 55, {
          fontFamily: "Geo",
          fontSize: 24,
          fontWeight: 'bold',
          fill: "#051155"
        });
        speechBubbleText.anchor.set( 0.5 );
        speechBubbleText.visible = false;

        upgradeImages.push( Unicorn.AddOverlay( "powerup", "powerup", -1000, 0 ) );
        upgradeImages.push( Unicorn.AddOverlay( "speedup", "speedup", -1000, 0 ) );
        upgradeImages.push( Unicorn.AddOverlay( "healup", "healup", -1000, 0 ) );
        upgradeImages.forEach( u => u.anchor.set( 0.5 ) );
        // Unicorn.AddDetector( "detect", {
        //   type: "rectangle",
        //   x: 64, y: 300,
        //   width: 128, height: 128
        // }, ( label, body ) => {
        //   console.log( "Enter:", label, body );
        //   Unicorn.PlaySound( "fart", {
        //     volume: 0.25
        //   } );
        // }, ( label, body ) => {
        //   console.log( "Exit:", label, body );
        // } );

        // TODO: Start game via chat command
        startVote();
      }

      function Update( timestamp, timeDiffInMs ) {
        // Add Update Loop
        // console.log( timestamp, timeDiffInMs );

        // Move Hearts to above Teapup
        for( var i = 0; i < tpMaxHP; i++ ) {
          var pX = tpTrike.position.x - 80 - 20;
          var pY = tpTrike.position.y - 110;
          tpEmptyHearts[ i ].position.x = pX + 40 * i;
          tpEmptyHearts[ i ].position.y = pY;
          tpFullHearts[ i ].position.x = pX + 40 * i;
          tpFullHearts[ i ].position.y = pY;
        }
        tpImage.x = tpTrike.position.x;
        tpImage.y = tpTrike.position.y;
        var dirX = Math.cos( tpTrike.angle );
        var dirY = Math.sin( tpTrike.angle );
        tpExhaust.forEach( ( e, i ) => {
          e.transform.rotation = tpTrike.angle;
          e.transform.scale.x = 0.5 + Math.sin( timestamp / 1000 * 20 + i * 5 ) * 0.1;
          e.transform.scale.y = 0.5 + Math.cos( timestamp / 1000 * 20 + i * 10 ) * 0.05;
          e.x = tpTrike.position.x - dirX * 50;
          e.y = tpTrike.position.y - dirY * 50;
        });

        voteText.visible = false;

        if( gameState === "vote" ) {
          if( voteTimer > 0 ) {
            voteTimer -= timeDiffInMs;
            voteTimeBar.transform.scale.x = voteTimer / voteTime;
          }

          driveTeapup( timeDiffInMs );
          aimTeapup( timeDiffInMs );

          var power = votePower, speed = voteSpeed, heal = voteHeal;
          Object.keys( votes ).forEach( v => {
            switch( votes[ v ] ) {
              case "power": power++; break;
              case "speed": speed++; break;
              case "heal": heal++; break;
            }
          } );
          var maxVotes = Math.max( power, Math.max( speed, heal ) );

          voteText.visible = true;
          if( tpTrike.position.x < 300 ) {
            tpVote[ 0 ].visible = false;
            tpVote[ 1 ].visible = true;
            tpVote[ 1 ].x = tpTrike.position.x + 30;
            tpVote[ 1 ].y = tpTrike.position.y - 120;
            voteText.x = tpVote[ 1 ].x + 120;
            voteText.y = tpVote[ 1 ].y + 40;
            voteTimeBar.x = tpVote[ 1 ].x + 10;
            voteTimeBar.y = tpVote[ 1 ].y + 79;
          }
          else {
            tpVote[ 1 ].visible = false;
            tpVote[ 0 ].visible = true;
            tpVote[ 0 ].x = tpTrike.position.x - 300;
            tpVote[ 0 ].y = tpTrike.position.y - 140;
            voteText.x = tpVote[ 0 ].x + 120;
            voteText.y = tpVote[ 0 ].y + 40;
            voteTimeBar.x = tpVote[ 0 ].x + 9;
            voteTimeBar.y = tpVote[ 0 ].y + 79;
          }
          if( power === maxVotes ) {
            voteStar.x = voteText.x - 75;
            voteStar.y = voteText.y - 45;
          }
          else if( speed === maxVotes ) {
            voteStar.x = voteText.x + 70;
            voteStar.y = voteText.y - 45;
          }
          else {
            voteStar.x = voteText.x - 3;
            voteStar.y = voteText.y - 45;
          }
          if( tpHP === 1 ) {
            // Auto-Select Heal
            voteTimer = 0;
            tpHP += 2;
            refreshVisibleHP();
            console.log( "Auto-Heal" );
            winningUpgrade = 2;
            upgradeAnimTimer = 2000;
            voteTimeBar.x = -1000;
            voteStar.x = -1000;
            startBattle();
          }
          else if( voteTimer <= 0 ) {
            console.log( "Power:", power );
            console.log( "Speed:", speed );
            console.log( "Heal:", heal );
            voteStar.x = -1000;
            if( power === maxVotes ) {
              console.log( "POWER UP" );
              firingCount++;
              tpHP--;
              refreshVisibleHP();
              winningUpgrade = 0;
            }
            else if( speed === maxVotes ) {
              console.log( "SPEED UP" );
              numFiringRateUpgrades++;
              firingRate *= 1 - 1 / numFiringRateUpgrades;
              tpSpeed++;
              tpHP--;
              refreshVisibleHP();
              winningUpgrade = 1;
            }
            else {
              console.log( "HEAL UP" );
              if( tpHP < tpMaxHP ) {
                tpHP += 2;
                if( tpHP > tpMaxHP ) {
                  tpHP = tpMaxHP;
                }
                refreshVisibleHP();
              }
              winningUpgrade = 2;
            }
            upgradeAnimTimer = 2000;
            voteTimeBar.x = -1000;
            startBattle();
          }
        }
        else {
          if( isSpeechBubbleShowing ) {
            var textIndex = isLongSpeechText ? 2 : 0;
            var textOffset = isLongSpeechText ? 80 : 0;
            speechBubbles.forEach( s => s.visible = false );
            if( isLongSpeechText ) {
              if( tpTrike.position.x < 500 ) {
                speechBubbles[ textIndex + 1 ].visible = true;
                speechBubbles[ textIndex + 1 ].x = tpTrike.position.x + 30;
                speechBubbles[ textIndex + 1 ].y = tpTrike.position.y - 120;
                speechBubbleText.x = speechBubbles[ textIndex + 1 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 1 ].y + 55;
              }
              else {
                speechBubbles[ textIndex + 0 ].visible = true;
                speechBubbles[ textIndex + 0 ].x = tpTrike.position.x - 440;
                speechBubbles[ textIndex + 0 ].y = tpTrike.position.y - 140;
                speechBubbleText.x = speechBubbles[ textIndex + 0 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 0 ].y + 55;
              }
            }
            else {
              if( tpTrike.position.x < 300 ) {
                speechBubbles[ textIndex + 1 ].visible = true;
                speechBubbles[ textIndex + 1 ].x = tpTrike.position.x + 30;
                speechBubbles[ textIndex + 1 ].y = tpTrike.position.y - 120;
                speechBubbleText.x = speechBubbles[ textIndex + 1 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 1 ].y + 55;
              }
              else {
                speechBubbles[ textIndex + 0 ].visible = true;
                speechBubbles[ textIndex + 0 ].x = tpTrike.position.x - 300;
                speechBubbles[ textIndex + 0 ].y = tpTrike.position.y - 140;
                speechBubbleText.x = speechBubbles[ textIndex + 0 ].x + textOffset + 120;
                speechBubbleText.y = speechBubbles[ textIndex + 0 ].y + 55;
              }
            }
          }
        }

        if( gameState === "battle" ) {
          tpVote[ 0 ].visible = false;
          tpVote[ 1 ].visible = false;
          if( shieldTimer > 0 ) {
            shieldTimer -= timeDiffInMs;
            tpImage.alpha = 0.75 + Math.sin( timestamp / 100 ) * 0.5;
            tpImage.tint = lerpColor( 0xff0000, 0xffffff, Math.min( tpImage.alpha, 1 ) );
          }
          else {
            tpImage.alpha = 1;
            tpImage.tint = 0xffffff;
          }

          if( upgradeAnimTimer > 0 ) {
            upgradeAnimTimer -= timeDiffInMs;
            var animProgress = upgradeAnimTimer / 2000;
            upgradeImages[ winningUpgrade ].x = tpTrike.position.x;
            upgradeImages[ winningUpgrade ].y = tpTrike.position.y - 240 + animProgress * 240;
            upgradeImages[ winningUpgrade ].alpha = animProgress;
            if( upgradeAnimTimer <= 0 ) {
              upgradeImages[ winningUpgrade ].x = -1000;
            }
          }

          if( isSpawningEnemies ) {
            warpSize += timeDiffInMs / 1000 * 2;
            if( warpSize > 1 ) {
              warpSize = 1;
            }
          }
          else if( warpSize > 0 ) {
            warpSize -= timeDiffInMs / 1000 * 2;
          }
          else {
            warpSize = 0;
          }

          if( warpSize > 0 ) {
            warpDark.transform.scale.x = warpDark.transform.scale.y = warpSize + Math.sin( timestamp / 21 ) * 0.05;
            warpLight.transform.scale.x = warpLight.transform.scale.y = warpSize + Math.sin( timestamp / 22 ) * 0.05;
          }
          else {
            warpDark.transform.scale.x = warpDark.transform.scale.y = 0;
            warpLight.transform.scale.x = warpLight.transform.scale.y = 0;
          }
          warpDark.transform.rotation = -timestamp / 100 * 0.81236;
          warpLight.transform.rotation = -timestamp / 100 * 0.576273;

          // Spawn enemies when the current wave is defeated
          if( !isSpawningEnemies && enemies.length <= 0 ) {
            waveNumber++;
            if( waveNumber > waveCount ) {
              startVote();
            }
            else {
              console.log( "WAVE:", waveNumber );
              spawnEnemyWave( ( enemyLevel - 1 ) * 3 + roundNumber * 3 + ( waveNumber - 1 ) );
            }
          }

          fireTime += timeDiffInMs;
          if( fireTime > firingRate ) {
            fireTime -= firingRate;
            for( var i = 0; i < firingCount; i++ ) {
              shootSkittle();
            }
          }

          driveTeapup( timeDiffInMs );
          aimTeapup( timeDiffInMs );

          skittles.forEach( (x, i) => {
            x.life -= timeDiffInMs;
            if( x.life <= 0 ) {
              // We've hit the ground
              skittles.splice( i, 1 );
              Unicorn.RemoveObject( x.label );
            }
          });

          enemies.forEach( ( x, i ) => {
            var dX = tpTrike.position.x - x.position.x;
            var dY = tpTrike.position.y - x.position.y;
            var length = Math.sqrt( dX * dX + dY * dY );
            // console.log( x );
            x.angle = Math.atan2( dY, dX );
            Matter.Body.setVelocity( x, { x: dX / length * x.moveSpeed, y: dY / length * x.moveSpeed });
          });
        }
      }

      function refreshVisibleHP() {
        for( var i = 0; i < tpFullHearts.length; i++ ) {
          // Only show upto the amount of life Teapup has
          tpFullHearts[ i ].visible = i < tpHP;
        }
      }

      function OnChatCommand( user, command, message, flags ) {
        // Handle Chat Commands
        if( gameState === "vote" ) {
          switch( command ) {
            case "power":
            case "speed":
            case "heal":
              // Add to tally
              console.log( user + " voted " + command );
              votes[ user ] = command;
              break;
          }
        }
        else {
          if( command === "say" ) {
            showSpeechBubble( message );
          }
        }

        if( command === "pupgrade" ) {
          if( tpHP > 1 ) {
            tpHP--;
            refreshVisibleHP();
            // hpText.text = tpHP;
            firingRate *= 0.75;
            firingCount++;
            tpSpeed++;
          }
        }
      }

      function OnChatMessage( user, message, flags, self ) {
        // Handle Chat Messages
        console.log( message );
      }

      function getRandomInt( max ) {
        return Math.floor( Math.random() * Math.floor( max ) );
      }

      // window.addEventListener('load', () => {
      // });

      function CreateGame() {
        Unicorn.Create( "unicorn-display", {
          width: 1280,
          height: 720,
          // background: 0x777777,// "transparent",
          background: "transparent",
          init: Init,
          update: Update,
          channel: "Instafluff",
          onCommand: OnChatCommand,
          onChat: OnChatMessage,
          // screenWalls: false, // Default: true
          // wallBottom: true,
          gravity: { x: 0, y: 0 },
          // gravity: { x: 0, y: 2 } // Default: { x: 0, y: 1 }
        });
      }
    </script>
  </body>
</html>
